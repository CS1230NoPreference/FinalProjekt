Similar to the design of previous assignments, the code is structured mostly in a functional manner, with somewhat heavy metaprogramming that repurposes the C++ core language features to make the actual filter code appear as intuitive and close to the mathematical form as possible. All filter code is self-contained in Filter.hxx, there is however another source code file Frame.hxx which abstracts away raw memory access when reading pixels.

The intermediate filtering results, including the input image, are represented as Frames. A frame is a 3D tensor that can be accessed by Frame[Channel][Row][Column]. Frame provides dynamic pixel remapping and therefore out-of-bounds access is EXPLICITLY ALLOWED. The filter never has to deal with edge cases when operating on frames. An out-of-bounds location will be mapped to an existing location, the remapping behavior is controlled by the OutOfBoundsRemapping member of a plane. It is reflection by default.

Operator* is overloaded to apply arbitrary kernel on a frame. It is not necessarily a convolution since the kernel could be non-linear such as a median. The kernel itself is a function that performs some calculations on the neighborhood of a particular sample, operator* is therefore a high order function. The rest of the filter code should be pretty self-explanatory and you should be able to understand at first glance. If you have a problem understanding certain C++ constructs in my code, or if the code does not compile for you, please consider referring to earlier readmes.

An additional filter (3x3 median) is implemented and could be applied using the “Special 1” option.
