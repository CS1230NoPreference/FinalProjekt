As I have explained in the algo assignment, metaprogramming and functional programming in general gives much greater abstraction power than inheritance-based OOP. The code of the entire Shape assignment is contained in a single file: Shape.hxx, it mostly follows a (non-pure) functional design with certain type level metaprogramming magic to reprogram C++’s core language features specifically for the assignment, to make things appear as intuitive as possible.

The code is very concise (100 something lines of code for everything) and highly flexible, it works not only for different types, some routines are universally quantified at kind level (google “higher kinded types” if you do not know what this means). No subclass is needed, at least for this assignment. However, if subclasses are required for future assignments, the code can be easily integrated into any subtype of Shape similarly to how it currently interacts with OpenGLShape.

An aggregate type (C++ terminology, a type that is trivially constructible) Vertex is defined, which contains the coordinates and normal of a vertex. A tessellated object is represented by F Vertex, where F is an iterable functor (in the categorical theoretical sense). Specifically for this assignment, F is either std::vector or std::array depending on the concrete use case. An Export function (Export: F Vertex -> std::vector GLFloat) is defined to convert any tessellated object to the low level representation that OpenGLShape can deal with.

Operator+ and operator+= are overloaded for any iterable type to make object concatenation more intuitive. Operator* is overloaded for Vertex and F Vertex to make transformations on a single vertex or an object closer to the mathematical notation. There is a variadic overload of operator* (F mat4 -> G Vertex -> F (G Vertex)) for objects, it is monoidal in terms that it preserves the cartesian product. Let F be std::array, you get “auto [x, y, z] = std::array{ T, R, S } * w” that x, y, z correspond to, respectively, T*w, R*w and S*w.

The smallest tessellation unit is a space quadrilateral consisting a top left vertex, a top right vertex, a bottom left vertex, and a bottom right vertex. The function for this atomic tessellation process is Shape::ImplementationDetail::Tile. The drawing function of every primitive object calls Tile to make sure that the sampled vertices are assembled in the correct (counterclockwise) order. Tile is a variadic higher order function, it is, at type level: forall …a. (a... -> Vertex) -> a… -> a… -> a… -> a… -> std::array Vertex 6. It takes a vertex generator and the corresponding arguments to generate 4 vertices of a space quadrilateral. It then tessellates the quadrilateral with 2 triangles.

The rest of the code is pretty self-explanatory and you should be able to understand at first glance. If you have a problem understanding certain C++ constructs in my code, or if the code does not compile for you, please consider referring to the Brush readme.
